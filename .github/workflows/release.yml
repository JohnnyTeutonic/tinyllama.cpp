name: Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag (e.g., v1.0.0)'
        required: true
        type: string
      prerelease:
        description: 'Is this a pre-release?'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  packages: write

jobs:
  create-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      upload_url: ${{ steps.create_release.outputs.upload_url }}
      version: ${{ github.event.inputs.version || github.ref_name }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create Tag
        if: github.event_name == 'workflow_dispatch'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git tag ${{ github.event.inputs.version }}
          git push origin ${{ github.event.inputs.version }}
          # Wait for tag to be available
          sleep 10
        
      - name: Create Release
        id: create_release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ github.event.inputs.version || github.ref_name }}
          name: Release ${{ github.event.inputs.version || github.ref_name }}
          draft: false
          prerelease: ${{ github.event.inputs.prerelease || false }}
          token: ${{ secrets.GITHUB_TOKEN }}

  build-and-release:
    permissions:
      contents: write
    needs: create-release
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest]
        include:
          - os: ubuntu-latest
            build_type: cpu
            artifact_name: tinyllama-linux-cpu
            asset_name: tinyllama-linux-cpu.tar.gz
            cmake_flags: "-DHAS_CUDA=OFF"
          - os: ubuntu-latest
            build_type: cuda
            artifact_name: tinyllama-linux-cuda
            asset_name: tinyllama-linux-cuda.tar.gz
            cmake_flags: "-DHAS_CUDA=ON"
          - os: windows-latest
            build_type: cpu
            artifact_name: tinyllama-windows-cpu
            asset_name: tinyllama-windows-cpu.zip
            cmake_flags: "-DHAS_CUDA=OFF"

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ needs.create-release.outputs.version }}

      - name: Setup CMake
        uses: jwlawson/actions-setup-cmake@v1.14
        with:
          cmake-version: '3.27.0'

      - name: Setup Mamba (Linux CUDA Build)
        if: runner.os == 'Linux' && matrix.build_type == 'cuda'
        uses: conda-incubator/setup-miniconda@v3.1.0
        with:
          activate-environment: "cuda-env"
          python-version: ${{ matrix.python-version || '3.10' }} # Default or from matrix if you add python versions
          miniforge-version: latest
          add-pip-as-python-dependency: true
          auto-activate-base: false

      - name: Install CUDA Toolkit 12.1.1 via Mamba (Linux CUDA Build)
        if: runner.os == 'Linux' && matrix.build_type == 'cuda'
        shell: bash -el {0} # Important for conda activation
        run: |
          echo "Installing CUDA 12.1.1 toolkit using Mamba..."
          mamba install -y -n cuda-env -c nvidia/label/cuda-12.1.1 cuda-toolkit
          echo "CONDA_PREFIX_1=$CONDA_PREFIX_1" # For debugging
          echo "CONDA_PREFIX=$CONDA_PREFIX" # For debugging
          echo "CUDA_HOME=${CONDA_PREFIX}" >> $GITHUB_ENV
          echo "CUDA_TOOLKIT_ROOT_DIR=${CONDA_PREFIX}" >> $GITHUB_ENV
          echo "LD_LIBRARY_PATH=${CONDA_PREFIX}/lib:${LD_LIBRARY_PATH}" >> $GITHUB_ENV
          echo "${CONDA_PREFIX}/bin" >> $GITHUB_PATH
          # Verify nvcc
          which nvcc
          nvcc --version

      - name: Install Dependencies (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential doxygen graphviz libboost-all-dev

      - name: Install Dependencies (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          Write-Host "Attempting to upgrade Chocolatey (default sources)..."
          choco upgrade chocolatey -y # Try without explicit source first for upgrade
          if ($LASTEXITCODE -ne 0) {
            Write-Warning "Chocolatey upgrade failed or was not necessary. Continuing..."
          }

          $packagesToInstall = @(
            @{ Name = "doxygen.install"; LogName = "Doxygen" },
            @{ Name = "graphviz"; LogName = "Graphviz" },
            @{ Name = "openssl"; LogName = "OpenSSL" },
            @{ Name = "boost-vc143"; LogName = "Boost (VC143)" }
          )
          $allSucceeded = $true

          foreach ($package in $packagesToInstall) {
            Write-Host "Attempting to install $($package.LogName) (default sources first)..."
            # Try without explicit source first
            choco install $($package.Name) -y --debug --verbose
            if ($LASTEXITCODE -ne 0) {
              Write-Warning "Failed to install $($package.LogName) with default sources. Exit code: $LASTEXITCODE. Retrying with explicit community source..."
              # Retry with explicit source
              choco install $($package.Name) -y --source https://community.chocolatey.org/api/v2/ --debug --verbose
              if ($LASTEXITCODE -ne 0) {
                Write-Error "Failed to install $($package.LogName) even with explicit community source. Exit code: $LASTEXITCODE"
                $allSucceeded = $false
              } else {
                Write-Host "$($package.LogName) installed successfully with explicit community source."
              }
            } else {
              Write-Host "$($package.LogName) installed successfully with default sources."
            }
          }

          if (-not $allSucceeded) {
            Write-Error "One or more Chocolatey packages failed to install."
            exit 1
          }
          Write-Host "All Chocolatey packages installed successfully."

      - name: Configure CMake (Linux)
        if: runner.os == 'Linux'
        shell: bash -el {0} # Ensure conda env is active if it's a CUDA build
        run: |
          mkdir build
          cd build
          if [ "${{ matrix.build_type }}" == "cuda" ]; then
            echo "Verifying nvcc path and CUDA_HOME / CUDA_TOOLKIT_ROOT_DIR:"
            which nvcc
            nvcc --version
            echo "CUDA_HOME is: $CUDA_HOME"
            echo "CUDA_TOOLKIT_ROOT_DIR is: $CUDA_TOOLKIT_ROOT_DIR"
            echo "LD_LIBRARY_PATH is: $LD_LIBRARY_PATH"
            if [ -z "$CUDA_HOME" ] || [ ! -f "$CUDA_HOME/bin/nvcc" ]; then
              echo "Error: CUDA_HOME is not correctly set or nvcc not found in $CUDA_HOME/bin/nvcc."
              exit 1
            fi
            # CMAKE_ARGS for CUDA
            export CMAKE_ARGS="-DCMAKE_CUDA_COMPILER=${CUDA_HOME}/bin/nvcc -DCMAKE_CUDA_ARCHITECTURES=all -DCMAKE_CUDA_FLAGS='-allow-unsupported-compiler'"
          fi
          cmake .. -DCMAKE_BUILD_TYPE=Release ${{ matrix.cmake_flags }} $CMAKE_ARGS

      - name: Configure CMake (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path build
          Set-Location build
          cmake .. -G "Visual Studio 17 2022" -A x64 -DCMAKE_BUILD_TYPE=Release ${{ matrix.cmake_flags }}

      - name: Build
        run: |
          cd build
          cmake --build . --config Release

      - name: Package (Linux)
        if: runner.os == 'Linux'
        run: |
          mkdir -p ${{ matrix.artifact_name }}
          cp build/tinyllama ${{ matrix.artifact_name }}/
          cp build/tinyllama_server ${{ matrix.artifact_name }}/
          cp README.md ${{ matrix.artifact_name }}/
          tar czf ${{ matrix.asset_name }} ${{ matrix.artifact_name }}

      - name: Package (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path ${{ matrix.artifact_name }}
          Copy-Item -Path "build/Release/tinyllama.exe" -Destination "${{ matrix.artifact_name }}/"
          Copy-Item -Path "build/Release/tinyllama_server.exe" -Destination "${{ matrix.artifact_name }}/"
          Copy-Item -Path "README.md" -Destination "${{ matrix.artifact_name }}/"
          7z a ${{ matrix.asset_name }} ${{ matrix.artifact_name }}

      - name: Upload Release Asset
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.create-release.outputs.version }}
          files: ${{ matrix.asset_name }}
          token: ${{ secrets.GITHUB_TOKEN }} 