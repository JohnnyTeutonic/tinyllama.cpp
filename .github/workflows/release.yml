name: Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag (e.g., v1.0.0)'
        required: true
        type: string
      prerelease:
        description: 'Is this a pre-release?'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  packages: write

jobs:
  create-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      upload_url: ${{ steps.create_release.outputs.upload_url }}
      version: ${{ github.event.inputs.version || github.ref_name }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create Tag
        if: github.event_name == 'workflow_dispatch'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git tag ${{ github.event.inputs.version }}
          git push origin ${{ github.event.inputs.version }}
          # Wait for tag to be available
          sleep 10
        
      - name: Create Release
        id: create_release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ github.event.inputs.version || github.ref_name }}
          name: Release ${{ github.event.inputs.version || github.ref_name }}
          draft: false
          prerelease: ${{ github.event.inputs.prerelease || false }}
          token: ${{ secrets.GITHUB_TOKEN }}

  build-and-release:
    permissions:
      contents: write
    needs: create-release
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest]
        include:
          - os: ubuntu-latest
            build_type: cpu
            artifact_name: tinyllama-linux-cpu
            asset_name: tinyllama-linux-cpu.tar.gz
            cmake_flags: "-DHAS_CUDA=OFF"
          - os: ubuntu-latest
            build_type: cuda
            artifact_name: tinyllama-linux-cuda
            asset_name: tinyllama-linux-cuda.tar.gz
            cmake_flags: "-DHAS_CUDA=ON"
          - os: windows-latest
            build_type: cpu
            artifact_name: tinyllama-windows-cpu
            asset_name: tinyllama-windows-cpu.zip
            cmake_flags: "-DHAS_CUDA=OFF"

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ needs.create-release.outputs.version }}

      - name: Cache Chocolatey packages and Boost (Windows)
        if: runner.os == 'Windows'
        uses: actions/cache@v4
        with:
          path: |
            C:\ProgramData\chocolatey\lib
            C:\ProgramData\Boost\boost_1.87.0
            C:\Boost
          key: ${{ runner.os }}-choco-boost-${{ hashFiles('**/release.yml') }} # Change if you modify the package list
          restore-keys: |
            ${{ runner.os }}-choco-boost-

      - name: Setup CMake
        uses: jwlawson/actions-setup-cmake@v1.14
        with:
          cmake-version: '3.27.0'

      - name: Setup Mamba (Linux CUDA Build)
        if: runner.os == 'Linux' && matrix.build_type == 'cuda'
        uses: conda-incubator/setup-miniconda@v3.1.0
        with:
          activate-environment: "cuda-env"
          python-version: ${{ matrix.python-version || '3.10' }} # Default or from matrix if you add python versions
          miniforge-version: latest
          add-pip-as-python-dependency: true
          auto-activate-base: false

      - name: Install CUDA Toolkit 12.1.1 via Mamba (Linux CUDA Build)
        if: runner.os == 'Linux' && matrix.build_type == 'cuda'
        shell: bash -el {0} # Important for conda activation
        run: |
          echo "Installing CUDA 12.1.1 toolkit using Mamba..."
          mamba install -y -n cuda-env -c nvidia/label/cuda-12.1.1 cuda-toolkit
          echo "CONDA_PREFIX_1=$CONDA_PREFIX_1" # For debugging
          echo "CONDA_PREFIX=$CONDA_PREFIX" # For debugging
          echo "CUDA_HOME=${CONDA_PREFIX}" >> $GITHUB_ENV
          echo "CUDA_TOOLKIT_ROOT_DIR=${CONDA_PREFIX}" >> $GITHUB_ENV
          echo "LD_LIBRARY_PATH=${CONDA_PREFIX}/lib:${LD_LIBRARY_PATH}" >> $GITHUB_ENV
          echo "${CONDA_PREFIX}/bin" >> $GITHUB_PATH
          # Verify nvcc
          which nvcc
          nvcc --version

      - name: Install Dependencies (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential doxygen graphviz libboost-all-dev
          if [ "${{ matrix.build_type }}" == "cuda" ]; then
            echo "Installing gcc-12 and g++-12 for CUDA build"
            sudo apt-get install -y gcc-12 g++-12
            echo "CC=/usr/bin/gcc-12" >> $GITHUB_ENV
            echo "CXX=/usr/bin/g++-12" >> $GITHUB_ENV
          fi

      - name: Install Dependencies (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          Write-Host "Attempting to upgrade Chocolatey (default sources)..."
          choco upgrade chocolatey -y # Try without explicit source first for upgrade
          if ($LASTEXITCODE -ne 0) {
            Write-Warning "Chocolatey upgrade failed or was not necessary. Continuing..."
          }

          $packagesToInstall = @(
            @{ Name = "doxygen.install"; LogName = "Doxygen" },
            @{ Name = "graphviz"; LogName = "Graphviz" },
            @{ Name = "openssl"; LogName = "OpenSSL" },
            @{ Name = "boost-msvc-14.2"; LogName = "Boost (MSVC 14.2)" }
          )
          $allSucceeded = $true

          foreach ($package in $packagesToInstall) {
            Write-Host "Attempting to install $($package.LogName) (default sources first)..."
            # Try without explicit source first
            choco install $($package.Name) -y --debug --verbose # Consider removing --debug --verbose later
            if ($LASTEXITCODE -ne 0) {
              Write-Warning "Failed to install $($package.LogName) with default sources. Exit code: $LASTEXITCODE. Retrying with explicit community source..."
              # Retry with explicit source
              choco install $($package.Name) -y --source https://community.chocolatey.org/api/v2/ --debug --verbose # Consider removing --debug --verbose later
              if ($LASTEXITCODE -ne 0) {
                Write-Error "Failed to install $($package.LogName) even with explicit community source. Exit code: $LASTEXITCODE"
                $allSucceeded = $false
              } else {
                Write-Host "$($package.LogName) installed successfully with explicit community source."
              }
            } else {
              Write-Host "$($package.LogName) installed successfully with default sources."
            }
          }

          if (-not $allSucceeded) {
            Write-Error "One or more Chocolatey packages failed to install."
            exit 1
          }
          Write-Host "All Chocolatey packages installed successfully."

      - name: Configure CMake (Linux)
        if: runner.os == 'Linux'
        env: # Make CC and CXX available here explicitly from GITHUB_ENV for CUDA builds
          CC: ${{ env.CC }}
          CXX: ${{ env.CXX }}
        shell: bash -el {0} # Ensure conda env is active if it's a CUDA build
        run: |
          mkdir build
          cd build
          CMAKE_EXTRA_ARGS="" # Renamed from CMAKE_ARGS to avoid conflicts
          if [ "${{ matrix.build_type }}" == "cuda" ]; then
            echo "Verifying nvcc path and CUDA_HOME / CUDA_TOOLKIT_ROOT_DIR:"
            which nvcc
            nvcc --version
            echo "CUDA_HOME is: $CUDA_HOME"
            echo "CUDA_TOOLKIT_ROOT_DIR is: $CUDA_TOOLKIT_ROOT_DIR"
            echo "LD_LIBRARY_PATH is: $LD_LIBRARY_PATH"
            if [ -z "$CUDA_HOME" ] || [ ! -f "$CUDA_HOME/bin/nvcc" ]; then
              echo "Error: CUDA_HOME is not correctly set or nvcc not found in $CUDA_HOME/bin/nvcc."
              exit 1
            fi
            
            # Determine host CXX for nvcc -ccbin
            HOST_CXX_FOR_NVCC="/usr/bin/g++-12" # Default to g++-12 after installation
            if [ -n "$CXX" ] && command -v $CXX &> /dev/null; then
                echo "Using CXX from GITHUB_ENV: $CXX for nvcc -ccbin"
                HOST_CXX_FOR_NVCC="$CXX"
            elif command -v /usr/bin/g++-12 &> /dev/null; then
                echo "GITHUB_ENV CXX not found or invalid, using /usr/bin/g++-12 for nvcc -ccbin"
                HOST_CXX_FOR_NVCC="/usr/bin/g++-12"
            else
                echo "Warning: Neither GITHUB_ENV CXX nor /usr/bin/g++-12 found. nvcc might pick an incompatible host compiler."
                # Let nvcc pick, or rely on -allow-unsupported-compiler if no specific g++-12 is found
            fi
            echo "Final host CXX for nvcc -ccbin: $HOST_CXX_FOR_NVCC"

            # CMAKE_ARGS for CUDA
            CMAKE_EXTRA_ARGS="-DCMAKE_CUDA_COMPILER=${CUDA_HOME}/bin/nvcc -DCMAKE_CUDA_ARCHITECTURES=all -DCMAKE_CUDA_FLAGS=\\"-allow-unsupported-compiler -ccbin ${HOST_CXX_FOR_NVCC}\\""
          fi
          cmake .. -DCMAKE_BUILD_TYPE=Release ${{ matrix.cmake_flags }} ${CMAKE_EXTRA_ARGS}

      - name: Configure CMake (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $BOOST_ROOT_DIR = "C:\ProgramData\Boost\boost_1.87.0"
          if (-not (Test-Path $BOOST_ROOT_DIR)) {
            # Fallback if the primary path doesn't exist, try the other cached path
            $BOOST_ROOT_DIR = "C:\local\boost_1_87_0"
            if (-not (Test-Path $BOOST_ROOT_DIR)) {
               $BOOST_ROOT_DIR = "C:\Boost" # Final fallback
            }
          }
          Write-Host "Setting BOOST_ROOT to $BOOST_ROOT_DIR"
          echo "BOOST_ROOT=$BOOST_ROOT_DIR" >> $env:GITHUB_ENV
          cmake .. -DCMAKE_BUILD_TYPE=Release -DBOOST_ROOT="$BOOST_ROOT_DIR" ${{ matrix.cmake_flags }}

      - name: Build
        run: |
          cd build
          cmake --build . --config Release

      - name: Package (Linux)
        if: runner.os == 'Linux'
        run: |
          mkdir -p ${{ matrix.artifact_name }}
          cp build/tinyllama ${{ matrix.artifact_name }}/
          cp build/tinyllama_server ${{ matrix.artifact_name }}/
          cp README.md ${{ matrix.artifact_name }}/
          tar czf ${{ matrix.asset_name }} ${{ matrix.artifact_name }}

      - name: Package (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path ${{ matrix.artifact_name }}
          Copy-Item -Path "build/Release/tinyllama.exe" -Destination "${{ matrix.artifact_name }}/"
          Copy-Item -Path "build/Release/tinyllama_server.exe" -Destination "${{ matrix.artifact_name }}/"
          Copy-Item -Path "README.md" -Destination "${{ matrix.artifact_name }}/"
          7z a ${{ matrix.asset_name }} ${{ matrix.artifact_name }}

      - name: Upload Release Asset
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.create-release.outputs.version }}
          files: ${{ matrix.asset_name }}
          token: ${{ secrets.GITHUB_TOKEN }} 