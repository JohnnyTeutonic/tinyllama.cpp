name: Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag (e.g., v1.0.0)'
        required: true
        type: string
      prerelease:
        description: 'Is this a pre-release?'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  packages: write

jobs:
  create-release:
    runs-on: ubuntu-22.04
    permissions:
      contents: write
    outputs:
      upload_url: ${{ steps.create_release.outputs.upload_url }}
      version: ${{ github.event.inputs.version || github.ref_name }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create Tag
        if: github.event_name == 'workflow_dispatch'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git tag ${{ github.event.inputs.version }}
          git push origin ${{ github.event.inputs.version }}
          # Wait for tag to be available
          sleep 10
        
      - name: Create Release
        id: create_release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ github.event.inputs.version || github.ref_name }}
          name: Release ${{ github.event.inputs.version || github.ref_name }}
          draft: false
          prerelease: ${{ github.event.inputs.prerelease || false }}
          token: ${{ secrets.GITHUB_TOKEN }}

  build-and-release:
    name: Build & Release (${{ matrix.os_name }} - ${{ matrix.build_type }})
    permissions:
      contents: write
    needs: create-release
    runs-on: ${{ matrix.os_runner }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os_name: Ubuntu-20.04-CPU-via-Docker
            os_runner: ubuntu-latest
            build_type: cpu
            artifact_name: tinyllama-linux-cpu-ubuntu2004
            asset_name: tinyllama-linux-cpu-ubuntu2004.tar.gz
            cmake_flags: "-DHAS_CUDA=OFF"
          - os_name: Ubuntu-20.04-CUDA-via-Docker
            os_runner: ubuntu-latest
            build_type: cuda
            artifact_name: tinyllama-linux-cuda-ubuntu2004
            asset_name: tinyllama-linux-cuda-ubuntu2004.tar.gz
            cmake_flags: "-DHAS_CUDA=ON"
          - os_name: Windows
            os_runner: windows-latest
            build_type: cpu
            artifact_name: tinyllama-windows-cpu
            asset_name: tinyllama-windows-cpu.zip
            cmake_flags: "-DHAS_CUDA=OFF"

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ needs.create-release.outputs.version }}

      - name: Cache Chocolatey packages and Boost (Windows)
        if: matrix.os_runner == 'windows-latest'
        if: runner.os == 'Windows'
        uses: actions/cache@v4
        with:
          path: |
            C:\ProgramData\chocolatey\lib
            C:\local\boost_1_87_0
            C:\Boost
          key: ${{ runner.os }}-choco-boost-1.87.0-${{ hashFiles('**/release.yml') }}
          restore-keys: |
            ${{ runner.os }}-choco-boost-1.87.0-
            ${{ runner.os }}-choco-boost-

      - name: Setup CMake
        uses: jwlawson/actions-setup-cmake@v1.14
        with:
          cmake-version: '3.27.0'

      - name: Setup Mamba (Linux CUDA Build)
        if: runner.os == 'Linux' && matrix.build_type == 'cuda'
        run: echo "Mamba setup for CUDA is now handled within the Docker image."

      - name: Install CUDA Toolkit 12.1.1 via Mamba (Linux CUDA Build)
        if: runner.os == 'Linux' && matrix.build_type == 'cuda'
        run: echo "CUDA Toolkit is provided by the NVIDIA Docker image."

      - name: Install Dependencies (Linux)
        if: runner.os == 'Linux' && matrix.build_type == 'cpu'
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential cmake libboost-all-dev doxygen graphviz
          # OpenMP for CPU builds
          sudo apt-get install -y libomp-dev

      - name: Build in Docker (Linux CUDA)
        if: runner.os == 'Linux' && matrix.build_type == 'cuda'
        run: |
          DOCKER_IMAGE="nvidia/cuda:12.1.1-devel-ubuntu20.04"
          echo "Pulling Docker image for CUDA build: $DOCKER_IMAGE"
          docker pull $DOCKER_IMAGE

          echo "Running CUDA build inside Docker container..."
          # Ensures the script fails if any command fails
          set -e

          # GitHub's GPU runners should have nvidia-container-toolkit for --gpus all
          docker run --gpus all --rm \
            -v "${{ github.workspace }}:/workspace" \
            -w /workspace \
            -e CMAKE_CUDA_ARCHITECTURES="all" \
            -e DEBIAN_FRONTEND=noninteractive \
            $DOCKER_IMAGE \
            /bin/bash -c ' \
              echo "--- Inside Docker ---" && \
              apt-get update && \
              echo "Installing build dependencies (cmake, boost, build-essential, git for versioning if needed by app)..." && \
              apt-get install -y --no-install-recommends cmake libboost-all-dev build-essential git && \
              \
              echo "Verifying nvcc and default gcc/g++ in Docker image:" && \
              nvcc --version && \
              gcc --version && \
              g++ --version && \
              \
              echo "Configuring CMake (CUDA within Docker)..." && \
              rm -rf build && \
              mkdir build && \
              cd build && \
              # The Docker image should have nvcc in PATH.
              # Boost_DEBUG and Boost_NO_SYSTEM_PATHS are more relevant for Windows, but harmless here.
              # matrix.cmake_flags (-DHAS_CUDA=ON) is passed from the host.
              # CMAKE_CUDA_ARCHITECTURES is passed via -e to docker run.
              # The devel image usually has a compatible host compiler for nvcc.
              cmake .. \
                -DCMAKE_BUILD_TYPE=Release \
                ${{ matrix.cmake_flags }} \
                -DCMAKE_CUDA_COMPILER=/usr/local/cuda/bin/nvcc \
                -DBoost_DEBUG=ON \
                -DBoost_NO_SYSTEM_PATHS=ON && \
              \
              echo "Building (CUDA within Docker)..." && \
              cmake --build . --config Release --target tinyllama tinyllama_server -j $(nproc) && \
              echo "--- Exiting Docker ---" \
            '
          echo "CUDA build completed."

      - name: Install Dependencies (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          Write-Host "Attempting to upgrade Chocolatey (default sources)..."
          choco upgrade chocolatey -y # Try without explicit source first for upgrade
          if ($LASTEXITCODE -ne 0) {
            Write-Warning "Chocolatey upgrade failed or was not necessary. Continuing..."
          }

          $packagesToInstall = @(
            @{ Name = "doxygen.install"; LogName = "Doxygen" },
            @{ Name = "graphviz"; LogName = "Graphviz" },
            @{ Name = "openssl"; LogName = "OpenSSL" },
            @{ Name = "boost-msvc-14.3"; Version = "1.81.0"; LogName = "Boost" } 
          )
          $allSucceeded = $true

          foreach ($package in $packagesToInstall) {
            $installArgs = @($package.Name, "-y", "--debug", "--verbose")
            if ($package.PSObject.Properties['Version']) {
              $installArgs += "--version=$($package.Version)"
            }
            
            Write-Host "Attempting to install $($package.LogName) (default sources first)..."
            choco install @installArgs
            if ($LASTEXITCODE -ne 0) {
              Write-Warning "Failed to install $($package.LogName) with default sources. Exit code: $LASTEXITCODE. Retrying with explicit community source..."
              $communityInstallArgs = $installArgs + "--source=https://community.chocolatey.org/api/v2/"
              choco install @communityInstallArgs
              if ($LASTEXITCODE -ne 0) {
                Write-Error "Failed to install $($package.LogName) even with explicit community source. Exit code: $LASTEXITCODE"
                $allSucceeded = $false
              } else {
                Write-Host "$($package.LogName) installed successfully with explicit community source."
              }
            } else {
              Write-Host "$($package.LogName) installed successfully with default sources."
            }
          }

          if (-not $allSucceeded) {
            Write-Error "One or more Chocolatey packages failed to install."
            exit 1
          }
          Write-Host "All Chocolatey packages installed successfully."

      - name: Configure CMake (Linux)
        if: runner.os == 'Linux' && matrix.build_type == 'cpu'
        env:
          CC: ${{ env.CC }}
          CXX: ${{ env.CXX }}
        shell: bash -el {0}
        run: |
          echo "DEBUG: Current matrix.os: ${{ matrix.os_runner }}, matrix.build_type: ${{ matrix.build_type }}"
          echo "DEBUG: Initial matrix.cmake_flags: ${{ matrix.cmake_flags }}"
          echo "Forcibly removing existing build directory if any..."
          rm -rf build
          mkdir build
          cd build
          CMAKE_EXTRA_ARGS=""
          echo "Configuring CMake with effective matrix.cmake_flags: ${{ matrix.cmake_flags }} and CMAKE_EXTRA_ARGS: ${CMAKE_EXTRA_ARGS}"
          cmake .. -DCMAKE_BUILD_TYPE=Release ${{ matrix.cmake_flags }} ${CMAKE_EXTRA_ARGS}

      - name: Configure CMake (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          # Attempt to clear any potentially conflicting environment variables first
          echo "BOOST_ROOT=" >> $env:GITHUB_ENV
          echo "BOOST_INCLUDEDIR=" >> $env:GITHUB_ENV
          echo "BOOST_LIBRARYDIR=" >> $env:GITHUB_ENV

          $BOOST_VERSION_UNDERSCORE = "1_87_0" # Adjusted to reflect actual installed version from logs
          $TARGET_BOOST_ROOT_DIR = "C:\local\boost_$($BOOST_VERSION_UNDERSCORE)"

          # We keep the Chocolatey install command attempting 1.81.0 as per original intent
          # but the paths above are changed to 1.87.0 for CMake to find what IS being installed.
          # This is a diagnostic step.

          if (-not (Test-Path $TARGET_BOOST_ROOT_DIR)) {
            Write-Warning "Boost not found at the expected installation path $TARGET_BOOST_ROOT_DIR. Trying C:\Boost as a fallback."
            $TARGET_BOOST_ROOT_DIR = "C:\Boost" # Generic fallback path
            if (-not (Test-Path $TARGET_BOOST_ROOT_DIR)) {
              Write-Warning "Boost also not found at C:\Boost. CMake configuration may fail if Boost is not discoverable by other means."
            }
          }
          
          Write-Host "Setting BOOST_ROOT for CMake to: $TARGET_BOOST_ROOT_DIR"
          echo "BOOST_ROOT=$TARGET_BOOST_ROOT_DIR" >> $env:GITHUB_ENV

          Write-Host "Listing contents of supposed BOOST_ROOT: $TARGET_BOOST_ROOT_DIR"
          Get-ChildItem -Path $TARGET_BOOST_ROOT_DIR -ErrorAction SilentlyContinue

          Write-Host "Checking for '$TARGET_BOOST_ROOT_DIR\boost' directory..."
          if (Test-Path "$TARGET_BOOST_ROOT_DIR\boost") {
              Write-Host "Found '$TARGET_BOOST_ROOT_DIR\boost'"
              Get-ChildItem -Path "$TARGET_BOOST_ROOT_DIR\boost" -Recurse -Depth 1 -ErrorAction SilentlyContinue | Select-Object -First 10
          } else {
              Write-Warning "'$TARGET_BOOST_ROOT_DIR\boost' NOT found."
          }

          Write-Host "Checking for '$TARGET_BOOST_ROOT_DIR\include\boost' directory..."
          if (Test-Path "$TARGET_BOOST_ROOT_DIR\include\boost") {
              Write-Host "Found '$TARGET_BOOST_ROOT_DIR\include\boost'"
              Get-ChildItem -Path "$TARGET_BOOST_ROOT_DIR\include\boost" -Recurse -Depth 1 -ErrorAction SilentlyContinue | Select-Object -First 10
          } else {
              Write-Warning "'$TARGET_BOOST_ROOT_DIR\include\boost' NOT found."
          }

          Write-Host "Listing contents of supposed Boost lib dir: $TARGET_BOOST_ROOT_DIR\lib64-msvc-14.3"
          Get-ChildItem -Path "$TARGET_BOOST_ROOT_DIR\lib64-msvc-14.3" -ErrorAction SilentlyContinue
          Write-Host "Listing contents of supposed Boost lib dir: $TARGET_BOOST_ROOT_DIR\lib32-msvc-14.3"
          Get-ChildItem -Path "$TARGET_BOOST_ROOT_DIR\lib32-msvc-14.3" -ErrorAction SilentlyContinue
          Write-Host "Listing contents of supposed Boost lib dir: $TARGET_BOOST_ROOT_DIR\lib"
          Get-ChildItem -Path "$TARGET_BOOST_ROOT_DIR\lib" -ErrorAction SilentlyContinue

          if (Test-Path "build") {
            Remove-Item -Recurse -Force "build" | Out-Null
          }
          New-Item -ItemType Directory -Force -Path "build"
          Set-Location "build"
          # Pass BOOST_ROOT directly, disable system path searching for Boost, and include Generator/Architecture
          # Also, explicitly unset BOOST_ROOT from cache first to ensure our value is taken
          # And now, also try explicitly setting Boost_INCLUDE_DIR based on typical Choco install path for boost-msvc packages
          cmake .. -U BOOST_ROOT -G "Visual Studio 17 2022" -A x64 -DCMAKE_BUILD_TYPE=Release -DBOOST_ROOT="$TARGET_BOOST_ROOT_DIR" -DBoost_INCLUDE_DIR="$TARGET_BOOST_ROOT_DIR" -DBoost_DEBUG=ON -DBoost_NO_SYSTEM_PATHS=ON ${{ matrix.cmake_flags }}

      - name: Build (Linux)
        if: runner.os == 'Linux' && matrix.build_type == 'cpu'
        shell: bash
        run: |
          cd build
          echo "Building Linux CPU targets: tinyllama, tinyllama_server"
          cmake --build . --config Release --target tinyllama tinyllama_server -j $(nproc)

      - name: Build (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          Set-Location build
          Write-Host "Building Windows targets: tinyllama, tinyllama_server"
          cmake --build . --config Release --target tinyllama tinyllama_server

      - name: Package (Linux)
        if: runner.os == 'Linux'
        run: |
          echo "Preparing Linux package for build type: ${{ matrix.build_type }}"
          echo "Listing contents of build directory:"
          ls -l build/
          
          ARTIFACT_DIR=${{ matrix.artifact_name }}
          mkdir -p $ARTIFACT_DIR
          
          echo "Copying executables..."
          if [ -f build/tinyllama ]; then
            cp build/tinyllama $ARTIFACT_DIR/
          else
            echo "ERROR: build/tinyllama not found!"
            exit 1
          fi
          
          if [ -f build/tinyllama_server ]; then
            cp build/tinyllama_server $ARTIFACT_DIR/
          else
            echo "ERROR: build/tinyllama_server not found! (This might be expected for SKBUILD if not a server build, but CI should build it)"
            # For CI release builds, tinyllama_server should generally be present unless specifically excluded by build_type logic
            if [ "${{ matrix.build_type }}" != "some_non_server_build_type_if_it_exists" ]; then # Adjust condition if needed
                 exit 1
            fi
          fi
          
          cp README.md $ARTIFACT_DIR/
          
          echo "Contents of staging directory $ARTIFACT_DIR:"
          ls -l $ARTIFACT_DIR
          
          echo "Creating tarball ${{ matrix.asset_name }}..."
          tar czf ${{ matrix.asset_name }} $ARTIFACT_DIR
          echo "Tarball created."

      - name: Package (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path ${{ matrix.artifact_name }}
          Copy-Item -Path "build/Release/tinyllama.exe" -Destination "${{ matrix.artifact_name }}/"
          Copy-Item -Path "build/Release/tinyllama_server.exe" -Destination "${{ matrix.artifact_name }}/"
          Copy-Item -Path "README.md" -Destination "${{ matrix.artifact_name }}/"
          7z a ${{ matrix.asset_name }} ${{ matrix.artifact_name }}

      - name: Upload Release Asset
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.create-release.outputs.version }}
          files: ${{ matrix.asset_name }}
          token: ${{ secrets.GITHUB_TOKEN }} 